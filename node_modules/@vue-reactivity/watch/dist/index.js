"use strict";Object.defineProperty(exports, "__esModule", {value: true});// src/errorHandling.ts
var _shared = require('@vue/shared');
function callWithErrorHandling(fn, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, type, args) {
  if (_shared.isFunction.call(void 0, fn)) {
    const res = callWithErrorHandling(fn, type, args);
    if (res && _shared.isPromise.call(void 0, res)) {
      res.catch((err) => {
        handleError(err, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++)
    values.push(callWithAsyncErrorHandling(fn[i], type, args));
  return values;
}
function handleError(err, type) {
  console.error(new Error(`[@vue-reactivity/watch]: ${type}`));
  console.error(err);
}
function warn(message) {
  console.warn(createError(message));
}
function createError(message) {
  return new Error(`[reactivue]: ${message}`);
}

// src/index.ts
var _reactivity = require('@vue/reactivity');

const invoke = (fn) => fn();
const INITIAL_WATCHER_VALUE = {};
function watchEffect(effect2, options) {
  return doWatch(effect2, null, options);
}
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, {immediate, deep, onTrack, onTrigger} = {}) {
  let getter;
  if (_shared.isArray.call(void 0, source) && !_reactivity.isReactive.call(void 0, source)) {
    getter = () => source.map((s) => {
      if (_reactivity.isRef.call(void 0, s))
        return s.value;
      else if (_reactivity.isReactive.call(void 0, s))
        return traverse(s);
      else if (_shared.isFunction.call(void 0, s))
        return callWithErrorHandling(s, "watch getter");
      else
        warn("invalid source");
    });
  } else if (_reactivity.isRef.call(void 0, source)) {
    getter = () => source.value;
  } else if (_reactivity.isReactive.call(void 0, source)) {
    getter = () => source;
    deep = true;
  } else if (_shared.isFunction.call(void 0, source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, "watch getter");
    } else {
      getter = () => {
        if (cleanup)
          cleanup();
        return callWithErrorHandling(source, "watch callback", [onInvalidate]);
      };
    }
  } else {
    getter = _shared.NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  const onInvalidate = (fn) => {
    cleanup = runner.options.onStop = () => {
      callWithErrorHandling(fn, "watch cleanup");
    };
  };
  let oldValue = _shared.isArray.call(void 0, source) ? [] : INITIAL_WATCHER_VALUE;
  const applyCb = cb ? () => {
    const newValue = runner();
    if (deep || _shared.hasChanged.call(void 0, newValue, oldValue)) {
      if (cleanup)
        cleanup();
      callWithAsyncErrorHandling(cb, "watch callback", [
        newValue,
        oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
        onInvalidate
      ]);
      oldValue = newValue;
    }
  } : void 0;
  const scheduler = invoke;
  const runner = _reactivity.effect.call(void 0, getter, {
    lazy: true,
    onTrack,
    onTrigger,
    scheduler: applyCb ? () => scheduler(applyCb) : scheduler
  });
  if (applyCb) {
    if (immediate)
      applyCb();
    else
      oldValue = runner();
  } else {
    runner();
  }
  const stopWatcher = function() {
    _reactivity.stop.call(void 0, runner);
  };
  stopWatcher.effect = runner;
  return stopWatcher;
}
function traverse(value, seen = new Set()) {
  if (!_shared.isObject.call(void 0, value) || seen.has(value))
    return value;
  seen.add(value);
  if (_shared.isArray.call(void 0, value)) {
    for (let i = 0; i < value.length; i++)
      traverse(value[i], seen);
  } else if (value instanceof Map) {
    value.forEach((_, key) => {
      traverse(value.get(key), seen);
    });
  } else if (value instanceof Set) {
    value.forEach((v) => {
      traverse(v, seen);
    });
  } else {
    for (const key of Object.keys(value))
      traverse(value[key], seen);
  }
  return value;
}



exports.watch = watch; exports.watchEffect = watchEffect;
