(() => {
  var __defineProperty = Object.defineProperty;
  var __hasOwnProperty = Object.prototype.hasOwnProperty;
  var __commonJS = (callback, module) => () => {
    if (!module) {
      module = {exports: {}};
      callback(module.exports, module);
    }
    return module.exports;
  };
  var __markAsModule = (target) => {
    return __defineProperty(target, "__esModule", {value: true});
  };
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defineProperty(target, name, {get: all[name], enumerable: true});
  };
  var __exportStar = (target, module) => {
    __markAsModule(target);
    if (typeof module === "object" || typeof module === "function") {
      for (let key in module)
        if (!__hasOwnProperty.call(target, key) && key !== "default")
          __defineProperty(target, key, {get: () => module[key], enumerable: true});
    }
    return target;
  };
  var __toModule = (module) => {
    if (module && module.__esModule)
      return module;
    return __exportStar(__defineProperty({}, "default", {value: module, enumerable: true}), module);
  };

  // src/index.ts
  var require_src = __commonJS((exports) => {
    __export(exports, {
      watch: () => watch,
      watchEffect: () => watchEffect
    });
    const reactivity = __toModule(require("@vue/reactivity"));
    const shared2 = __toModule(require("@vue/shared"));
    const invoke = (fn) => fn();
    const INITIAL_WATCHER_VALUE = {};
    function watchEffect(effect2, options) {
      return doWatch(effect2, null, options);
    }
    function watch(source, cb, options) {
      return doWatch(source, cb, options);
    }
    function doWatch(source, cb, {immediate, deep, onTrack, onTrigger} = {}) {
      let getter;
      if (shared2.isArray(source) && !reactivity.isReactive(source)) {
        getter = () => source.map((s) => {
          if (reactivity.isRef(s))
            return s.value;
          else if (reactivity.isReactive(s))
            return traverse(s);
          else if (shared2.isFunction(s))
            return callWithErrorHandling(s, "watch getter");
          else
            warn("invalid source");
        });
      } else if (reactivity.isRef(source)) {
        getter = () => source.value;
      } else if (reactivity.isReactive(source)) {
        getter = () => source;
        deep = true;
      } else if (shared2.isFunction(source)) {
        if (cb) {
          getter = () => callWithErrorHandling(source, "watch getter");
        } else {
          getter = () => {
            if (cleanup)
              cleanup();
            return callWithErrorHandling(source, "watch callback", [onInvalidate]);
          };
        }
      } else {
        getter = shared2.NOOP;
      }
      if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
      }
      let cleanup;
      const onInvalidate = (fn) => {
        cleanup = runner.options.onStop = () => {
          callWithErrorHandling(fn, "watch cleanup");
        };
      };
      let oldValue = shared2.isArray(source) ? [] : INITIAL_WATCHER_VALUE;
      const applyCb = cb ? () => {
        const newValue = runner();
        if (deep || shared2.hasChanged(newValue, oldValue)) {
          if (cleanup)
            cleanup();
          callWithAsyncErrorHandling(cb, "watch callback", [
            newValue,
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
            onInvalidate
          ]);
          oldValue = newValue;
        }
      } : void 0;
      const scheduler = invoke;
      const runner = reactivity.effect(getter, {
        lazy: true,
        onTrack,
        onTrigger,
        scheduler: applyCb ? () => scheduler(applyCb) : scheduler
      });
      if (applyCb) {
        if (immediate)
          applyCb();
        else
          oldValue = runner();
      } else {
        runner();
      }
      const stopWatcher = function() {
        reactivity.stop(runner);
      };
      stopWatcher.effect = runner;
      return stopWatcher;
    }
    function traverse(value, seen = new Set()) {
      if (!shared2.isObject(value) || seen.has(value))
        return value;
      seen.add(value);
      if (shared2.isArray(value)) {
        for (let i = 0; i < value.length; i++)
          traverse(value[i], seen);
      } else if (value instanceof Map) {
        value.forEach((_, key) => {
          traverse(value.get(key), seen);
        });
      } else if (value instanceof Set) {
        value.forEach((v) => {
          traverse(v, seen);
        });
      } else {
        for (const key of Object.keys(value))
          traverse(value[key], seen);
      }
      return value;
    }
  });

  // src/errorHandling.ts
  const shared = __toModule(require("@vue/shared"));
  function callWithErrorHandling(fn, type, args) {
    let res;
    try {
      res = args ? fn(...args) : fn();
    } catch (err) {
      handleError(err, type);
    }
    return res;
  }
  function callWithAsyncErrorHandling(fn, type, args) {
    if (shared.isFunction(fn)) {
      const res = callWithErrorHandling(fn, type, args);
      if (res && shared.isPromise(res)) {
        res.catch((err) => {
          handleError(err, type);
        });
      }
      return res;
    }
    const values = [];
    for (let i = 0; i < fn.length; i++)
      values.push(callWithAsyncErrorHandling(fn[i], type, args));
    return values;
  }
  function handleError(err, type) {
    console.error(new Error(`[@vue-reactivity/watch]: ${type}`));
    console.error(err);
  }
  function warn(message) {
    console.warn(createError(message));
  }
  function createError(message) {
    return new Error(`[reactivue]: ${message}`);
  }
  require_src();
})();
